Bean信息定义4种方式

1.API的方式

先来说这种方式，因为其他几种方式最终都会采用这种方式来定义bean配置信息。

Spring容器启动的过程中，会将Bean解析成Spring内部的BeanDefinition结构。
不管是是通过xml配置文件的<Bean>标签，还是通过注解配置的@Bean，还是@Compontent标注的类，还是扫描得到的类，它最终都会被解析成一个BeanDefinition对象，最后我们的Bean工厂就会根据这份Bean的定义信息，对bean进行实例化、初始化等等操作。

你可以把BeanDefinition丢给Bean工厂，然后Bean工厂就会根据这个信息帮你生产一个Bean实例，拿去使用。

BeanDefinition里面里面包含了bean定义的各种信息，如：bean对应的class、scope、lazy信息、dependOn信息、autowireCandidate（是否是候选对象）、primary（是否是主要的候选者）等信息。

BeanDefinition接口：bean定义信息接口




RootBeanDefinition类：表示根bean定义信息

通常bean中没有父bean的就使用这种表示

ChildBeanDefinition类：表示子bean定义信息

如果需要指定父bean的，可以使用ChildBeanDefinition来定义子bean的配置信息，里面有个parentName属性，用来指定父bean的名称。

GenericBeanDefinition类：通用的bean定义信息

既可以表示没有父bean的bean配置信息，也可以表示有父bean的子bean配置信息，这个类里面也有parentName属性，用来指定父bean的名称。

ConfigurationClassBeanDefinition类：表示通过配置类中@Bean方法定义bean信息

可以通过配置类中使用@Bean来标注一些方法，通过这些方法来定义bean，这些方法配置的bean信息最后会转换为ConfigurationClassBeanDefinition类型的对象

AnnotatedBeanDefinition接口：表示通过注解的方式定义的bean信息

里面有个方法

AnnotationMetadata getMetadata();
用来获取定义这个bean的类上的所有注解信息。




BeanDefinitionBuilder：构建BeanDefinition的工具类




RuntimeBeanReference：用来表示bean引用类型，类似于xml中的ref

ManagedList：属性如果是List类型的，需要用到这个类进行操作，这个类继承了ArrayList

ManagedSet：属性如果是Set类型的，需要用到这个类进行操作，这个类继承了LinkedHashSet

ManagedMap：属性如果是Map类型的，需要用到这个类进行操作，这个类继承了LinkedHashMap


2.Xml文件方式

xml中的bean配置信息会被解析器解析为BeanDefinition对象

3. properties文件的方式

将bean定义信息放在properties文件中，然后通过解析器将配置信息解析为BeanDefinition对象。

4.注解的方式

类上标注@Compontent注解来定义一个bean
配置类中使用@Bean注解来定义bean

小结

bean注册者只识别BeanDefinition对象，不管什么方式最后都会将这些bean定义的信息转换为BeanDefinition对象，然后注册到spring容器中。




阶段2：Bean元信息解析阶段

Bean元信息的解析就是将各种方式定义的bean配置信息解析为BeanDefinition对象。

Bean元信息的解析主要有3种方式

1 xml文件定义bean的解析
2 properties文件定义bean的解析
3 注解方式定义bean的解析

XML方式解析：XmlBeanDefinitionReader，将xml中定义的bean解析为BeanDefinition对象。



阶段3：Spring Bean注册阶段

bean注册阶段需要用到一个非常重要的接口：BeanDefinitionRegistry

别名注册接口：AliasRegistry

BeanDefinitionRegistry接口继承了AliasRegistry接口，这个接口中定义了操作bean别名的一些方法

BeanDefinitionRegistry唯一实现：DefaultListableBeanFactory

spring中BeanDefinitionRegistry接口有一个唯一的实现类：

org.springframework.beans.factory.support.DefaultListableBeanFactory
大家可能看到有很多类也实现了BeanDefinitionRegistry接口，比如我们经常用到的AnnotationConfigApplicationContext，但实际上其内部是转发给了DefaultListableBeanFactory进行处理的，所以真正实现这个接口的类是DefaultListableBeanFactory。



从：BeanDefinition合并阶段到Bean初始化完成阶段，都是在调用getBean从容器中获取bean对象的过程中发生的操作，要注意细看了，大家下去了建议去看getBean这个方法的源码，以下过程均来自于这个方法：

org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean。



阶段4：BeanDefinition合并阶段

合并阶段是做什么的？

可能我们定义bean的时候有父子bean关系，此时子BeanDefinition中的信息是不完整的，比如设置属性的时候配置在父BeanDefinition中，此时子BeanDefinition中是没有这些信息的，需要将子bean的BeanDefinition和父bean的BeanDefinition进行合并，得到最终的一个RootBeanDefinition，合并之后得到的RootBeanDefinition包含bean定义的所有信息，包含了从父bean中继继承过来的所有信息，后续bean的所有创建工作就是依靠合并之后BeanDefinition来进行的。

合并BeanDefinition会使用下面这个方法：

org.springframework.beans.factory.support.AbstractBeanFactory#getMergedBeanDefinition
bean定义可能存在多级父子关系，合并的时候进进行递归合并，最终得到一个包含完整信息的RootBeanDefinition


合并之前，BeanDefinition是不完整的，比lesson2和lesson3中的class是null，属性信息也不完整，但是合并之后这些信息都完整了。

合并之前是GenericBeanDefinition类型的，合并之后得到的是RootBeanDefinition类型的。

获取lesson3合并的BeanDefinition时，内部会递归进行合并，先将lesson1和lesson2合并，然后将lesson2再和lesson3合并，最后得到合并之后的BeanDefinition。

后面的阶段将使用合并产生的RootBeanDefinition。



阶段5：Bean Class加载阶段

这个阶段就是将bean的class名称转换为Class类型的对象。

BeanDefinition中有个Object类型的字段：beanClass

private volatile Object beanClass;
用来表示bean的class对象，通常这个字段的值有2种类型，一种是bean对应的Class类型的对象，另一种是bean对应的Class的完整类名，第一种情况不需要解析，第二种情况：即这个字段是bean的类名的时候，就需要通过类加载器将其转换为一个Class对象。

此时会对阶段4中合并产生的RootBeanDefinition中的beanClass进行解析，将bean的类名转换为Class对象，然后赋值给beanClass字段。

源码位置：

org.springframework.beans.factory.support.AbstractBeanFactory#resolveBeanClass


上面得到了Bean Class对象以及合并之后的BeanDefinition，下面就开始进入实例化这个对象的阶段了。

Bean实例化分为3个阶段：前阶段、实例化阶段、后阶段；下面详解介绍。

阶段6：Bean实例化阶段

分2个小的阶段

Bean实例化前操作
Bean实例化操作


BeanPostProcessor是一个接口，还有很多子接口，这些接口中提供了很多方法，spring在bean生命周期的不同阶段，会调用上面这个列表中的BeanPostProcessor中的一些方法，来对生命周期进行扩展，bean生命周期中的所有扩展点都是依靠这个集合中的BeanPostProcessor来实现的，所以如果大家想对bean的生命周期进行干预，这块一定要掌握好。

注意：本文中很多以BeanPostProcessor结尾的，都实现了BeanPostProcessor接口，有些是直接实现的，有些是实现了它的子接口。

这段代码在bean实例化之前给开发者留了个口子，开发者自己可以在这个地方直接去创建一个对象作为bean实例，而跳过spring内部实例化bean的过程。

上面代码中轮询beanPostProcessors列表，如果类型是InstantiationAwareBeanPostProcessor， 尝试调用InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation获取bean的实例对象，如果能够获取到，那么将返回值作为当前bean的实例，那么spring自带的实例化bean的过程就被跳过了。


Bean实例化操作

这个过程可以干什么？

这个过程会通过反射来调用bean的构造器来创建bean的实例。

具体需要使用哪个构造器，spring为开发者提供了一个接口，允许开发者自己来判断用哪个构造器。



阶段7：合并后的BeanDefinition处理
会调用MergedBeanDefinitionPostProcessor接口的postProcessMergedBeanDefinition方法


第一个参数为beanDefinition，表示合并之后的RootBeanDefinition，我们可以在这个方法内部对合并之后的BeanDefinition进行再次处理

postProcessMergedBeanDefinition有2个实现类，前面我们介绍过，用的也比较多，ms的时候也会经常问的：

org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor
在 postProcessMergedBeanDefinition 方法中对 @Autowired、@Value 标注的方法、字段进行缓存

org.springframework.context.annotation.CommonAnnotationBeanPostProcessor
在 postProcessMergedBeanDefinition 方法中对 @Resource 标注的字段、@Resource 标注的方法、 @PostConstruct 标注的字段、 @PreDestroy标注的方法进行缓存



阶段8：Bean属性设置阶段

属性设置阶段分为3个小的阶段

实例化后阶段
Bean属性赋值前处理
Bean属性赋值

实例化后阶段
会调用InstantiationAwareBeanPostProcessor接口的postProcessAfterInstantiation这个方法
postProcessAfterInstantiation方法返回false的时候，后续的Bean属性赋值前处理、Bean属性赋值都会被跳过了

Bean属性赋值前阶段
这个阶段会调用InstantiationAwareBeanPostProcessor接口的postProcessProperties方法
如果InstantiationAwareBeanPostProcessor中的postProcessProperties和postProcessPropertyValues都返回空的时候，表示这个bean不需要设置属性，直接返回了，直接进入下一个阶段

PropertyValues中保存了bean实例对象中所有属性值的设置，所以我们可以在postProcessProperties方法中对PropertyValues值进行修改。
这个方法有2个比较重要的实现类

AutowiredAnnotationBeanPostProcessor在这个方法中对@Autowired、@Value标注的字段、方法注入值。
CommonAnnotationBeanPostProcessor在这个方法中对@Resource标注的字段和方法注入值。

Bean属性赋值阶段

这个过程比较简单了，循环处理PropertyValues中的属性值信息，通过反射调用set方法将属性的值设置到bean实例中。

PropertyValues中的值是通过bean xml中property元素配置的，或者调用MutablePropertyValues中add方法设置的值。



阶段9：Bean初始化阶段

这个阶段分为5个小的阶段

Bean Aware接口回调

Bean初始化前操作

Bean初始化操作

Bean初始化后操作

Bean初始化完成操作


Bean Aware接口回调invokeAwareMethods
如果我们的bean实例实现了上面的接口，会按照下面的顺序依次进行调用：
BeanNameAware：将bean的名称注入进去
BeanClassLoaderAware：将BeanClassLoader注入进去
BeanFactoryAware：将BeanFactory注入进去


Bean初始化前操作
会调用BeanPostProcessor的postProcessBeforeInitialization方法，若返回null，当前方法将结束。

通常称postProcessBeforeInitialization这个方法为：bean初始化前操作。

这个接口有2个实现类，比较重要：
org.springframework.context.support.ApplicationContextAwareProcessor
org.springframework.context.annotation.CommonAnnotationBeanPostProcessor


ApplicationContextAwareProcessor给bean实例注入6个Aware接口对象
如果bean实现了上面的接口，在ApplicationContextAwareProcessor#postProcessBeforeInitialization中会依次调用下面接口中的方法，将Aware前缀对应的对象‘注入到bean实例中’。
EnvironmentAware：注入Environment对象
EmbeddedValueResolverAware：注入EmbeddedValueResolver对象
ResourceLoaderAware：注入ResourceLoader对象
ApplicationEventPublisherAware：注入ApplicationEventPublisher对象
MessageSourceAware：注入MessageSource对象
ApplicationContextAware：注入ApplicationContext对象
从名称上可以看出这个类以ApplicationContext开头的，说明这个类只能在ApplicationContext环境中使用。


CommonAnnotationBeanPostProcessor（继承了InitDestroyAnnotationBeanPostProcessor）#postProcessBeforeInitialization中会调用bean中所有标注@PostConstruct注解的方法
在postProcessBeforeInitialization方法的invokeInitMethods(bean, beanName)中调用




Bean初始化

2个步骤
调用InitializingBean接口的afterPropertiesSet方法
调用定义bean的时候指定的初始化方法。


来看一下InitializingBean这个接口

public interface InitializingBean {

    void afterPropertiesSet() throws Exception;

}
当我们的bean实现了InitializingBean这个接口的时候，会在这个阶段被调用


调用bean定义的时候指定的初始化方法

先来看一下如何指定bean的初始化方法，3种方式

方式1：xml方式指定初始化方法
<bean init-method="bean中方法名称"/>

方式2：@Bean的方式指定初始化方法
@Bean(initMethod = "初始化的方法")

方式3：api的方式指定初始化方法
beanDefinition.setInitMethodName(methodName);

初始化方法最终会赋值给下面这个字段
org.springframework.beans.factory.support.AbstractBeanDefinition#initMethodName


调用顺序：InitializingBean中的afterPropertiesSet、然后在调用自定义的初始化方法


Bean初始化后会调用BeanPostProcessor接口的postProcessAfterInitialization方法，返回null的时候，会中断上面的操作。
通常称postProcessAfterInitialization这个方法为：bean初始化后置操作。



阶段10：所有单例bean实例化完成后阶段

所有单例bean‘实例化完成’之后，spring会回调下面这个接口：

public interface SmartInitializingSingleton {
    void afterSingletonsInstantiated();
}


带有ApplicationContext的容器，内部最终都会调用org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons：
触发所有单例bean的初始化；然后从容器中找到类型是SmartInitializingSingleton的bean，‘自动’调用他们的‘afterSingletonsInstantiated方法’。

案例1：ApplicationContext自动回调SmartInitializingSingleton接口

案例2：通过api的方式让DefaultListableBeanFactory去回调SmartInitializingSingleton
上面通过api的方式注册bean
最后调用factory.preInstantiateSingletons触发所有非lazy单例bean初始化，所有bean装配完毕之后，会回调SmartInitializingSingleton接口。




阶段11：Bean使用阶段
调用getBean方法得到了bean之后，随意使用




阶段12：Bean销毁阶段

触发bean销毁的几种方式：
调用org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#destroyBean
调用org.springframework.beans.factory.config.ConfigurableBeanFactory#destroySingletons
调用ApplicationContext中的close方法


DestructionAwareBeanPostProcessor接口有个‘关键的实现类’：org.springframework.context.annotation.CommonAnnotationBeanPostProcessor
CommonAnnotationBeanPostProcessor#postProcessBeforeDestruction方法，会调用‘bean中所有标注了@PreDestroy的方法’。

自定义销毁方法有3种方式：

方式1：xml中指定销毁方法
<bean destroy-method="bean中方法名称"/>

方式2：@Bean中指定销毁方法
@Bean(destroyMethod = "初始化的方法")

方式3：api的方式指定销毁方法
this.beanDefinition.setDestroyMethodName(methodName);


案例1：自定义DestructionAwareBeanPostProcessor
案例2：触发@PreDestroy标注的方法被调用
案例3：看一下销毁阶段的执行顺序


实际上ApplicationContext内部已经将spring内部一些常见的必须的BeanPostProcessor自动装配到beanPostProcessors列表中，比如我们熟悉的下面的几个：

1.org.springframework.context.annotation.CommonAnnotationBeanPostProcessor
  用来处理@Resource、@PostConstruct、@PreDestroy的
2.org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor
  用来处理@Autowired、@Value注解
3.org.springframework.context.support.ApplicationContextAwareProcessor
  用来回调Bean实现的各种Aware接口
  
  
所以通过ApplicationContext.close()来销毁bean，会触发3中方式都执行。
Bean销毁阶段会依次执行:
1轮询beanPostProcessors列表，如果是DestructionAwareBeanPostProcessor接口，会调用其内部的postProcessBeforeDestruction方法
2如果bean实现了org.springframework.beans.factory.DisposableBean接口，会调用这个接口中的destroy方法
3调用bean自定义的销毁方法

初始化bean完毕后，会调用registerDisposableBeanIfNecessary(beanName, bean, mbd);
Register bean as disposable并放入disposableBeans的map中；等待销毁时取得待销毁的bean的map,遍历执行销毁
真正执行销毁的是DisposableBeanAdapter#destroy()方法，会依次执行如下3中销毁方式：
@PreDestroy标注的所有方法
DisposableBean接口中的destroy()
自定义的销毁方法
